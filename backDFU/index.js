const cors = require('cors');
const mongoose = require('mongoose');
const express = require('express');
const multer = require('multer'); // Para upload de arquivos
const { bucket } = require('./config/firebase');

// Importar modelos
const Analise = require('./models/Analise');
const Profissional = require('./models/Profissional');
const Paciente = require('./models/Paciente');

// Carrega as vari√°veis de ambiente do arquivo .env
require('dotenv').config({ path: './.env' });

const app = express();
// Railway define a porta automaticamente atrav√©s da vari√°vel PORT
const port = process.env.PORT || 3000;

// M√≥dulos para requisi√ß√µes HTTP e manipula√ß√£o de arquivos
const axios = require('axios');
const FormData = require('form-data');
const fs = require('fs');
const path = require('path');
const stream = require('stream'); // Necess√°rio para criar o stream do buffer

// Middlewares
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Configura√ß√£o do multer para upload de arquivos (em mem√≥ria para Railway)
const storage = multer.memoryStorage();
const upload = multer({
    storage: storage,
    limits: {
        fileSize: 10 * 1024 * 1024 // Limite de 10MB
    }
});

// Vari√°vel de ambiente MONGO_URI
const MONGO_URI = process.env.MONGO_URI;
// URL base da API Python
const PYTHON_API_BASE_URL = process.env.PYTHON_API_URL;
if (!PYTHON_API_BASE_URL) {
    console.error('‚ùå Erro: A vari√°vel de ambiente PYTHON_API_URL n√£o est√° configurada.');
    process.exit(1);
}

// Conectar ao MongoDB Atlas
mongoose.connect(MONGO_URI)
    .then(() => console.log('‚úÖ Conectado ao MongoDB Atlas'))
    .catch((err) => console.error('‚ùå Erro na conex√£o:', err));

// Importa√ß√£o das rotas
const pacienteRoute = require('./routes/pacienteRoute');
const logupRoute = require('./routes/logupRoute');
const profissionalRoutes = require('./routes/profissionalRoute');

app.use('/pacientes', pacienteRoute);
app.use('/logup', logupRoute);
app.use('/profissionais', profissionalRoutes);

// Rota de sa√∫de para verificar se o servidor est√° funcionando
app.get('/health', (req, res) => {
    res.json({
        status: 'OK',
        timestamp: new Date().toISOString(),
        service: 'Node.js API'
    });
});

/**
 * Endpoint para a primeira etapa do fluxo: Detec√ß√£o de Bounding Boxes.
 * Recebe a imagem original e a repassa para a API Python para detec√ß√£o.
 * Retorna as boxes detectadas e as informa√ß√µes de redimensionamento.
 */
// ENDPOINT DETECTAR
app.post('/api/detect-ulcers', upload.single('file'), async (req, res) => {
    try {
        if (!req.file) {
            return res.status(400).json({
                success: false,
                message: 'Nenhuma imagem foi enviada'
            });
        }

        console.log('--- Etapa 1: Detec√ß√£o de √ölceras ---');
        console.log(`üì§ Enviando imagem para detec√ß√£o...`);

        const formDetection = new FormData();
        formDetection.append('file', stream.Readable.from(req.file.buffer), {
            filename: req.file.originalname || 'ulcera.jpg',
            contentType: req.file.mimetype || 'image/jpeg'
        });

        const urlDetection = `${PYTHON_API_BASE_URL}/predict/detection`;
        const responseDetection = await axios.post(urlDetection, formDetection, {
            headers: formDetection.getHeaders(),
            timeout: 60000 // 60 segundos para IA
        });

        console.log(`‚úÖ Detec√ß√£o conclu√≠da. Encontradas ${responseDetection.data.deteccoes.length} regi√µes.`);

        // ‚≠ê CONVERTER IMAGEM PARA BASE64 E RETORNAR NO FORMATO ESPERADO
        const imageBase64 = req.file.buffer.toString('base64');

        res.json({
            success: true,
            message: 'Detec√ß√£o realizada com sucesso',
            imagem_redimensionada: imageBase64,
            boxes: responseDetection.data.deteccoes,
            dimensoes: {
                width: responseDetection.data.info_redimensionamento?.original_size?.width || 640,
                height: responseDetection.data.info_redimensionamento?.original_size?.height || 640
            },
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        console.error('‚ùå Erro na detec√ß√£o:', error.message);
        res.status(500).json({
            success: false,
            message: error.message || 'Erro na detec√ß√£o de √∫lceras'
        });
    }
});

/**
 * Endpoint para a segunda etapa do fluxo: Classifica√ß√£o de Regi√µes.
 * Recebe a imagem original e o JSON das boxes editadas pelo usu√°rio.
 * Repassa para a API Python para classifica√ß√£o.
 * Retorna os resultados finais.
 */

app.post('/api/classify-regions', express.json(), async (req, res) => {
    try {
        const { imagem_redimensionada, boxes_finais, medico_id, paciente_id } = req.body;

        if (!imagem_redimensionada || !boxes_finais) {
            return res.status(400).json({
                success: false,
                message: 'Dados insuficientes para classifica√ß√£o'
            });
        }

        console.log('--- Etapa 2: Classifica√ß√£o das Regi√µes ---');
        console.log(`üì§ Classificando ${boxes_finais.length} regi√µes...`);

        // Converter base64 para buffer
        const imageBuffer = Buffer.from(imagem_redimensionada, 'base64');

        const formClassification = new FormData();
        formClassification.append('file', stream.Readable.from(imageBuffer), {
            filename: 'ulcera_analise.jpg',
            contentType: 'image/jpeg'
        });
        formClassification.append('deteccoes_json', JSON.stringify(boxes_finais));

        const urlClassification = `${PYTHON_API_BASE_URL}/predict/classification`;
        const responseClassification = await axios.post(urlClassification, formClassification, {
            headers: formClassification.getHeaders(),
            timeout: 60000
        });

        console.log(`‚úÖ Classifica√ß√£o conclu√≠da. ${responseClassification.data.resultados.length} resultados.`);

        // ‚≠ê PROCESSAR RESULTADOS PARA FRONTEND
        const resultados_classificacao = responseClassification.data.resultados.map((resultado, index) => {
            // Criar subimagem (crop da regi√£o)
            const subimagem_base64 = criarSubimagem(imagem_redimensionada, resultado);

            return {
                xmin: resultado.xmin,
                ymin: resultado.ymin,
                xmax: resultado.xmax,
                ymax: resultado.ymax,
                classe_classificacao: resultado.classe_classificacao,
                confianca_classificacao: resultado.confianca_classificacao,
                subimagem: subimagem_base64
            };
        });

        res.json({
            success: true,
            message: 'Classifica√ß√£o realizada com sucesso',
            resultados_classificacao,
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        console.error('‚ùå Erro na classifica√ß√£o:', error.message);
        res.status(500).json({
            success: false,
            message: error.message || 'Erro na classifica√ß√£o das regi√µes'
        });
    }
});


// ‚≠ê FUN√á√ÉO HELPER PARA CRIAR SUBIMAGEM
function criarSubimagem(imageBase64, regiao) {
    try {
        // Em uma implementa√ß√£o real, voc√™ usaria uma biblioteca como sharp ou jimp
        // Por enquanto, retorna a imagem original como placeholder
        return imageBase64;
    } catch (error) {
        console.error('Erro ao criar subimagem:', error);
        return imageBase64;
    }
}

app.post('/api/save-analysis', express.json(), async (req, res) => {
    try {
        const { 
            medico_id,  // UID do Firebase
            paciente_id, 
            imagem_original, 
            regioes_analisadas, 
            diagnostico_geral 
        } = req.body;

        if (!medico_id || !paciente_id || !diagnostico_geral || !imagem_original) {
            return res.status(400).json({
                success: false,
                message: 'Dados obrigat√≥rios ausentes'
            });
        }

        console.log('--- Etapa 3: Salvando An√°lise ---');
        
        // ‚≠ê BUSCAR M√âDICO PELO UID DO FIREBASE
        const medico = await Profissional.findOne({ firebaseUid: medico_id });
        if (!medico) {
            return res.status(404).json({
                success: false,
                message: 'M√©dico n√£o encontrado'
            });
        }

        // ‚≠ê VERIFICAR SE PACIENTE PERTENCE AO M√âDICO
        const paciente = await Paciente.findOne({ 
            _id: paciente_id,
            medicoId: medico._id
        });
        if (!paciente) {
            return res.status(404).json({
                success: false,
                message: 'Paciente n√£o encontrado ou n√£o pertence a voc√™'
            });
        }

        // ‚≠ê CRIAR NOVA AN√ÅLISE COM ObjectId CORRETO
        const novaAnalise = new Analise({
            medicoId: medico._id,        // ‚úÖ ObjectId do MongoDB
            pacienteId: paciente_id,     // ‚úÖ ObjectId do MongoDB
            originalImageUrl: '',        // Ser√° preenchido ap√≥s upload
            boxes: (regioes_analisadas || []).map(regiao => ({
                xMin: regiao.coordenadas?.xmin || 0,
                yMin: regiao.coordenadas?.ymin || 0,
                xMax: regiao.coordenadas?.xmax || 0,
                yMax: regiao.coordenadas?.ymax || 0,
                classification: {
                    label: regiao.classificacao_ia?.classe || 'N√£o classificado',
                    confidence: regiao.classificacao_ia?.confianca || 0
                },
                diagnosis: regiao.diagnostico_medico || ''
            })),
            imageDiagnosis: diagnostico_geral
        });

        // ‚≠ê SALVAR PARA GERAR O _id
        await novaAnalise.save();
        console.log(`üìù An√°lise criada no MongoDB com ID: ${novaAnalise._id}`);

        // ‚≠ê GERAR NOME DO ARQUIVO (usando ObjectIds do MongoDB)
        const nomeArquivo = `${medico._id}_${paciente_id}_${novaAnalise._id}.jpg`;
        console.log(`üì§ Fazendo upload da imagem: ${nomeArquivo}`);

        // ‚≠ê UPLOAD DA IMAGEM PARA FIREBASE STORAGE
        const imageBuffer = Buffer.from(imagem_original, 'base64');
        const file = bucket.file(`analises/${nomeArquivo}`);
        
        const stream = file.createWriteStream({
            metadata: {
                contentType: 'image/jpeg',
                metadata: {
                    medicoId: medico._id.toString(),
                    medicoFirebaseUid: medico_id,
                    pacienteId: paciente_id,
                    analiseId: novaAnalise._id.toString(),
                    uploadDate: new Date().toISOString()
                }
            }
        });

        // ‚≠ê PROMISE PARA AGUARDAR O UPLOAD
        const uploadPromise = new Promise((resolve, reject) => {
            stream.on('error', (error) => {
                console.error('‚ùå Erro no upload:', error);
                reject(error);
            });

            stream.on('finish', async () => {
                try {
                    // ‚≠ê TORNAR O ARQUIVO P√öBLICO E OBTER URL
                    await file.makePublic();
                    const publicUrl = `https://storage.googleapis.com/${bucket.name}/analises/${nomeArquivo}`;
                    console.log(`‚úÖ Upload conclu√≠do: ${publicUrl}`);
                    resolve(publicUrl);
                } catch (error) {
                    console.error('‚ùå Erro ao tornar p√∫blico:', error);
                    reject(error);
                }
            });
        });

        // ‚≠ê ENVIAR BUFFER PARA O STREAM
        stream.end(imageBuffer);

        // ‚≠ê AGUARDAR UPLOAD COMPLETAR
        const firebaseUrl = await uploadPromise;

        // ‚≠ê ATUALIZAR AN√ÅLISE COM URL DA IMAGEM
        novaAnalise.originalImageUrl = firebaseUrl;
        await novaAnalise.save();

        console.log(`‚úÖ An√°lise completa salva para paciente ${paciente.nome}`);
        console.log(`üîó URL da imagem: ${firebaseUrl}`);

        res.json({
            success: true,
            message: 'An√°lise salva com sucesso',
            analise_id: novaAnalise._id.toString(),
            firebase_url: firebaseUrl,
            nome_arquivo: nomeArquivo,
            medico: {
                id: medico._id,
                nome: medico.nome,
                firebaseUid: medico.firebaseUid
            },
            paciente: {
                id: paciente._id,
                nome: paciente.nome
            },
            timestamp: new Date().toISOString()
        });

    } catch (error) {
        console.error('‚ùå Erro ao salvar an√°lise:', error.message);
        
        // ‚≠ê CLEANUP: Se houve erro, tentar deletar an√°lise incompleta
        if (error.analiseId) {
            try {
                await Analise.findByIdAndDelete(error.analiseId);
                console.log('üßπ An√°lise incompleta removida do MongoDB');
            } catch (cleanupError) {
                console.error('‚ùå Erro no cleanup:', cleanupError.message);
            }
        }

        res.status(500).json({
            success: false,
            message: error.message || 'Erro ao salvar an√°lise',
            details: process.env.NODE_ENV === 'development' ? error.stack : undefined
        });
    }
});

app.get('/analises/:id', async (req, res) => {
    try {
        const { id } = req.params;
        
        if (!mongoose.Types.ObjectId.isValid(id)) {
            return res.status(400).json({
                success: false,
                message: 'ID da an√°lise inv√°lido'
            });
        }

        const analise = await Analise.findById(id)
            .populate('medicoId', 'nome email firebaseUid')
            .populate('pacienteId', 'nome cpf telefone email');

        if (!analise) {
            return res.status(404).json({
                success: false,
                message: 'An√°lise n√£o encontrada'
            });
        }

        res.json({
            success: true,
            data: analise
        });

    } catch (error) {
        console.error('‚ùå Erro ao buscar an√°lise:', error.message);
        res.status(500).json({
            success: false,
            message: 'Erro ao buscar an√°lise'
        });
    }
});

// ‚≠ê LISTAR AN√ÅLISES DE UM PACIENTE
app.get('/pacientes/:pacienteId/analises', async (req, res) => {
    try {
        const { pacienteId } = req.params;

        if (!mongoose.Types.ObjectId.isValid(pacienteId)) {
            return res.status(400).json({
                success: false,
                message: 'ID do paciente inv√°lido'
            });
        }

        const analises = await Analise.find({ pacienteId })
            .populate('medicoId', 'nome email')
            .sort({ createdAt: -1 }); // Mais recentes primeiro

        res.json({
            success: true,
            data: analises,
            total: analises.length
        });

    } catch (error) {
        console.error('‚ùå Erro ao buscar an√°lises:', error.message);
        res.status(500).json({
            success: false,
            message: 'Erro ao buscar an√°lises'
        });
    }
});



// Middleware para capturar rotas n√£o encontradas
app.use((req, res) => {
    res.status(404).json({
        erro: 'Rota n√£o encontrada',
        message: `A rota ${req.method} ${req.originalUrl} n√£o existe`,
        rotas_disponiveis: [
            'GET /health',
            'POST /api/detect-ulcers',
            'POST /api/classify-regions',
            'POST /api/save-analysis',
            'GET /analises/:id',
            'GET /pacientes/:pacienteId/analises',
            'GET /pacientes',
            'POST /logup'
        ]
    });
});

// Middleware para tratamento de erros globais
app.use((error, req, res, next) => {
    console.error('‚ùå Erro n√£o tratado:', error);
    res.status(500).json({
        erro: 'Erro interno do servidor',
        message: 'Ocorreu um erro inesperado'
    });
});

// Graceful shutdown
process.on('SIGTERM', () => {
    console.log('üîÑ Recebido SIGTERM, encerrando servidor...');
    mongoose.connection.close().then(() => {
        console.log('üîí Conex√£o com MongoDB fechada');
        process.exit(0);
    });
});

// Inicia o servidor
app.listen(port, '0.0.0.0', () => {
    console.log(`üöÄ Servidor Node.js rodando na porta ${port}`);
    console.log(`üåê Health check: http://localhost:${port}/health`);
    console.log(`üîó Python API URL: ${PYTHON_API_BASE_URL}`);
    console.log(`üìù MongoDB: ${MONGO_URI ? 'Configurado' : 'N√£o configurado'}`);
});